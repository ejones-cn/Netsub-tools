#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
IP子网切分计算器

提供IP子网切分的核心功能，包括:
1. IP地址和整数之间的转换
2. 获取子网的详细信息
3. 检查子网关系
4. 执行子网切分
"""

# 导入版本管理模块
import sys
import os
import json
import csv
import io

sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from version import get_version

__version__ = get_version()

import ipaddress


def ip_to_int(ip_str):
    """
    将IP地址字符串转换为整数
    """
    parts = ip_str.split(".")
    return int(parts[0]) << 24 | int(parts[1]) << 16 | int(parts[2]) << 8 | int(parts[3])


def int_to_ip(ip_int):
    """
    将整数转换为IP地址字符串
    """
    return f"{ip_int >> 24}.{(ip_int >> 16) & 0xFF}.{(ip_int >> 8) & 0xFF}.{ip_int & 0xFF}"


def get_subnet_info(network_str):
    """
    获取子网的详细信息
    """
    try:
        network = ipaddress.IPv4Network(network_str, strict=False)

        # 计算通配符掩码：子网掩码的反码
        wildcard = ~int(network.netmask) & 0xFFFFFFFF
        wildcard_mask = int_to_ip(wildcard)
        
        # 计算可用主机范围
        host_range_start = str(network.network_address + 1) if network.num_addresses > 2 else str(network.network_address)
        host_range_end = str(network.broadcast_address - 1) if network.num_addresses > 2 else str(network.broadcast_address)
        
        # 获取可用主机数量
        number_of_hosts = network.num_addresses - 2 if network.num_addresses > 2 else network.num_addresses

        return {
            "network": str(network.network_address),
            "netmask": str(network.netmask),
            "wildcard": wildcard_mask,
            "broadcast": str(network.broadcast_address),
            "cidr": str(network.with_prefixlen),
            "prefixlen": network.prefixlen,
            "num_addresses": network.num_addresses,
            "usable_addresses": number_of_hosts,
            # 以下是为了兼容导出函数添加的键
            "network_address": str(network.network_address),
            "subnet_mask": str(network.netmask),
            "prefix_length": network.prefixlen,
            "broadcast_address": str(network.broadcast_address),
            "host_range_start": host_range_start,
            "host_range_end": host_range_end,
            "number_of_hosts": number_of_hosts
        }
    except ValueError as e:
        return {"error": str(e)}


def split_subnet(parent_cidr, split_cidr):
    """
    将split_cidr从parent_cidr中切分出来，返回剩余的子网列表
    """
    try:
        parent_net = ipaddress.IPv4Network(parent_cidr, strict=False)
        split_net = ipaddress.IPv4Network(split_cidr, strict=False)

        # 检查split_net是否是parent_net的子网
        if not split_net.subnet_of(parent_net):
            return {"error": f"{split_cidr} 不是 {parent_cidr} 的子网"}

        # 如果父网段和切分网段相同，直接返回空列表
        if parent_net == split_net:
            return {
                "parent": parent_cidr,
                "split": split_cidr,
                "remaining_subnets": [],
                "split_info": get_subnet_info(split_cidr),
                "remaining_subnets_info": [],
            }

        # 使用Python ipaddress模块的address_exclude方法获取剩余网段
        # 这个方法会自动生成最简洁的剩余网段列表
        remaining = list(parent_net.address_exclude(split_net))

        # 对剩余网段按CIDR进行排序
        remaining.sort()

        return {
            "parent": parent_cidr,
            "split": split_cidr,
            "remaining_subnets": [str(subnet) for subnet in remaining],
            "split_info": get_subnet_info(split_cidr),
            "remaining_subnets_info": [get_subnet_info(str(subnet)) for subnet in remaining],
        }

    except ValueError as e:
        return {"error": str(e)}


def suggest_subnet_planning(parent_cidr, required_subnets):
    """
    子网规划智能建议功能

    参数:
    parent_cidr: 父网段，格式为CIDR (例如: "10.0.0.0/8")
    required_subnets: 需要的子网列表，每个子网包含name和hosts两个字段

    返回:
    包含建议子网规划的字典
    """
    try:
        parent_net = ipaddress.IPv4Network(parent_cidr, strict=False)

        # 按所需主机数量从大到小排序，优先分配大的子网
        sorted_subnets = sorted(required_subnets, key=lambda x: x["hosts"], reverse=True)

        # 计算每个子网需要的CIDR前缀长度
        for subnet in sorted_subnets:
            # 计算需要的地址数量（包括网络地址和广播地址）
            required_addresses = subnet["hosts"] + 2
            # 计算合适的前缀长度
            prefix_len = 32 - (required_addresses - 1).bit_length()
            # 确保前缀长度不小于父网段的前缀长度
            prefix_len = max(prefix_len, parent_net.prefixlen)
            subnet["prefix_len"] = prefix_len

        # 开始分配子网
        available_subnets = [parent_net]
        allocated_subnets = []

        for required in sorted_subnets:
            allocated = False

            # 尝试在可用子网中找到合适的网段
            for i, available in enumerate(available_subnets):
                # 检查可用子网是否有足够的空间
                if available.prefixlen <= required["prefix_len"]:
                    # 创建所需的子网
                    new_subnet = list(available.subnets(new_prefix=required["prefix_len"]))[0]

                    # 分配该子网
                    allocated_subnets.append(
                        {
                            "name": required["name"],
                            "cidr": str(new_subnet),
                            "required_hosts": required["hosts"],
                            "available_hosts": (
                                new_subnet.num_addresses - 2
                                if new_subnet.num_addresses > 2
                                else new_subnet.num_addresses
                            ),
                            "info": get_subnet_info(str(new_subnet)),
                        }
                    )

                    # 更新可用子网列表
                    remaining = list(available.address_exclude(new_subnet))
                    available_subnets.pop(i)
                    available_subnets.extend(remaining)
                    available_subnets.sort()  # 保持排序

                    allocated = True
                    break

            if not allocated:
                return {"error": f"无法为 {required['name']} 分配足够大的子网空间"}

        return {
            "parent_cidr": parent_cidr,
            "required_subnets": required_subnets,
            "allocated_subnets": allocated_subnets,
            "remaining_subnets": [str(subnet) for subnet in available_subnets],
            "remaining_subnets_info": [
                get_subnet_info(str(subnet)) for subnet in available_subnets
            ],
        }

    except ValueError as e:
        return {"error": str(e)}


# 测试示例
if __name__ == "__main__":
    # 测试子网切分
    print("=== 测试子网切分功能 ===")
    result = split_subnet("10.0.0.0/8", "10.21.60.0/23")
    if "error" in result:
        print(f"错误: {result['error']}")
    else:
        print(f"父网段: {result['parent']}")
        print(f"切分网段: {result['split']}")
        print("\n切分网段信息:")
        for key, value in result["split_info"].items():
            print(f"  {key}: {value}")
        print(f"\n剩余网段 ({len(result['remaining_subnets'])} 个):")
        for i, subnet in enumerate(result["remaining_subnets_info"], 1):
            print(f"\n网段 {i}:")
            for key, value in subnet.items():
                print(f"  {key}: {value}")

    # 测试子网规划智能建议
    print("\n=== 测试子网规划智能建议功能 ===")
    required_subnets = [
        {"name": "办公区", "hosts": 200},
        {"name": "服务器区", "hosts": 50},
        {"name": "研发部", "hosts": 100},
        {"name": "测试环境", "hosts": 30},
    ]

    plan = suggest_subnet_planning("192.168.0.0/16", required_subnets)
    if "error" in plan:
        print(f"错误: {plan['error']}")
    else:
        print(f"父网段: {plan['parent_cidr']}")
        print(f"\n已分配子网:")
        for subnet in plan["allocated_subnets"]:
            print(f"\n{subnet['name']}:")
            print(f"  CIDR: {subnet['cidr']}")
            print(f"  需求主机数: {subnet['required_hosts']}")
            print(f"  可用主机数: {subnet['available_hosts']}")
            print(f"  网络地址: {subnet['info']['network']}")
            print(f"  子网掩码: {subnet['info']['netmask']}")
            print(f"  广播地址: {subnet['info']['broadcast']}")

        print(f"\n剩余网段 ({len(plan['remaining_subnets'])} 个):")
        for i, subnet in enumerate(plan["remaining_subnets_info"], 1):
            print(f"\n网段 {i}: {subnet['cidr']}")


def export_to_csv(data, delimiter=","):
    """
    将子网信息导出为CSV格式

    Args:
        data (list): 子网信息列表，每个元素为get_subnet_info返回的字典
        delimiter (str): CSV分隔符

    Returns:
        str: CSV格式的子网信息
    """
    if not data:
        return ""

    # 定义CSV列名
    fieldnames = [
        "network_address",
        "subnet_mask",
        "prefix_length",
        "broadcast_address",
        "host_range_start",
        "host_range_end",
        "number_of_hosts",
        "cidr",
    ]

    output = io.StringIO()
    writer = csv.DictWriter(output, fieldnames=fieldnames, delimiter=delimiter)

    writer.writeheader()
    for item in data:
        writer.writerow(item)

    return output.getvalue()


def export_to_json(data, indent=2):
    """
    将子网信息导出为JSON格式

    Args:
        data (list): 子网信息列表，每个元素为get_subnet_info返回的字典
        indent (int): JSON缩进空格数

    Returns:
        str: JSON格式的子网信息
    """
    return json.dumps(data, indent=indent, ensure_ascii=False)


def export_to_text(data):
    """
    将子网信息导出为文本格式

    Args:
        data (list): 子网信息列表，每个元素为get_subnet_info返回的字典

    Returns:
        str: 文本格式的子网信息
    """
    output = ""
    for i, item in enumerate(data, 1):
        output += f"子网 #{i}:\n"
        output += f"  网络地址: {item['network_address']}\n"
        output += f"  子网掩码: {item['subnet_mask']}\n"
        output += f"  前缀长度: {item['prefix_length']}\n"
        output += f"  广播地址: {item['broadcast_address']}\n"
        output += f"  可用主机范围: {item['host_range_start']} - {item['host_range_end']}\n"
        output += f"  可用主机数量: {item['number_of_hosts']}\n"
        output += f"  CIDR表示: {item['cidr']}\n"
    output += "\n"
    return output


def export_to_pdf(data, file_path):
    """
    将子网信息导出为PDF格式

    Args:
        data (list): 子网信息列表，每个元素为get_subnet_info返回的字典
        file_path (str): 输出PDF文件路径

    Returns:
        bool: 导出是否成功
    """
    try:
        from reportlab.lib.pagesizes import A4
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
        from reportlab.lib import colors
        from reportlab.pdfbase import pdfmetrics
        from reportlab.pdfbase.ttfonts import TTFont
        import os
        import sys

        # 注册中文字体
        def register_chinese_fonts():
            # 尝试查找系统中的中文字体
            font_path = None
            font_name = None

            # Windows系统字体路径
            if sys.platform == "win32":
                font_dir = "C:\\Windows\\Fonts"
                if os.path.exists(font_dir):
                    # 检查常用中文字体（包含.ttf和.ttc格式）
                    font_candidates = [
                        ("simhei.ttf", "SimHei"),  # 黑体
                        ("simsun.ttc", "SimSun"),  # 宋体
                        ("msyh.ttf", "Microsoft YaHei"),  # 微软雅黑
                        ("msyhbd.ttf", "Microsoft YaHei Bold"),  # 微软雅黑粗体
                        ("msyhui.ttf", "Microsoft YaHei UI"),
                        ("stsong.ttf", "STSong"),  # 华文宋体
                        ("stheiti.ttf", "STHeiti"),  # 华文黑体
                        ("stkaiti.ttf", "STKaiti"),  # 华文楷体
                    ]

                    # 查找所有可用的字体，优先使用黑体
                    for font_file, font_family in font_candidates:
                        potential_path = os.path.join(font_dir, font_file)
                        if os.path.exists(potential_path):
                            font_path = potential_path
                            font_name = font_family
                            # 如果找到黑体，直接使用
                            if font_file.lower() == "simhei.ttf":
                                break

            # 如果找到中文字体，注册它
            if font_path:
                try:
                    # 注册字体
                    pdfmetrics.registerFont(TTFont("ChineseFont", font_path))
                    return True
                except Exception as e:
                    print(f"注册字体失败: {e}")
                    return False
            else:
                print("未找到可用的中文字体")
                return False

        # 注册中文字体
        has_chinese_font = register_chinese_fonts()

        # 创建PDF文档
        doc = SimpleDocTemplate(file_path, pagesize=A4)
        elements = []
        styles = getSampleStyleSheet()

        # 创建支持中文的标题样式
        title_style = ParagraphStyle(
            "ChineseTitle",
            parent=styles["Title"],
            fontName="ChineseFont" if has_chinese_font else "Helvetica-Bold",
            fontSize=18,
            textColor=colors.black,
            alignment=1,  # 居中对齐
        )

        # 创建支持中文的表格样式
        table_text_style = ParagraphStyle(
            "ChineseTableText",
            parent=styles["Normal"],
            fontName="ChineseFont" if has_chinese_font else "Helvetica",
            fontSize=10,
            alignment=1,  # 居中对齐
        )

        table_header_style = ParagraphStyle(
            "ChineseTableHeader",
            parent=styles["Normal"],
            fontName="ChineseFont" if has_chinese_font else "Helvetica-Bold",
            fontSize=12,
            textColor=colors.whitesmoke,
            alignment=1,  # 居中对齐
        )

        # 添加标题
        elements.append(Paragraph("IP子网分割工具 - 计算结果", title_style))
        elements.append(Spacer(1, 20))

        # 定义表格数据，将所有中文文本用Paragraph包裹
        table_data = [
            [
                Paragraph("网络地址", table_header_style),
                Paragraph("子网掩码", table_header_style),
                Paragraph("前缀长度", table_header_style),
                Paragraph("广播地址", table_header_style),
                Paragraph("可用主机范围", table_header_style),
                Paragraph("可用主机数量", table_header_style),
                Paragraph("CIDR表示", table_header_style),
            ]
        ]

        for item in data:
            host_range = f"{item['host_range_start']} - {item['host_range_end']}"
            table_data.append(
                [
                    Paragraph(item["network_address"], table_text_style),
                    Paragraph(item["subnet_mask"], table_text_style),
                    Paragraph(str(item["prefix_length"]), table_text_style),
                    Paragraph(item["broadcast_address"], table_text_style),
                    Paragraph(host_range, table_text_style),
                    Paragraph(str(item["number_of_hosts"]), table_text_style),
                    Paragraph(item["cidr"], table_text_style),
                ]
            )

        # 创建表格
        table = Table(table_data, hAlign="CENTER")

        # 设置表格样式
        table_style = TableStyle(
            [
                ("BACKGROUND", (0, 0), (-1, 0), colors.grey),
                ("ALIGN", (0, 0), (-1, -1), "CENTER"),
                ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                ("FONTSIZE", (0, 0), (-1, 0), 12),
                ("BOTTOMPADDING", (0, 0), (-1, 0), 12),
                ("TOPPADDING", (0, 0), (-1, 0), 12),
                ("LEFTPADDING", (0, 0), (-1, -1), 6),
                ("RIGHTPADDING", (0, 0), (-1, -1), 6),
                ("GRID", (0, 0), (-1, -1), 1, colors.black),
            ]
        )

        # 设置表格内容的字体已经在Paragraph中设置，这里不需要再设置FONTNAME

        table.setStyle(table_style)

        # 添加表格到文档
        elements.append(table)

        # 生成PDF
        doc.build(elements)
        return True
    except Exception as e:
        print(f"PDF导出失败: {str(e)}")
        return False


def export_to_excel(data, file_path):
    """
    将子网信息导出为Excel格式

    Args:
        data (list): 子网信息列表，每个元素为get_subnet_info返回的字典
        file_path (str): 输出Excel文件路径

    Returns:
        bool: 导出是否成功
    """
    try:
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment

        # 创建Excel工作簿
        wb = Workbook()
        ws = wb.active
        ws.title = "子网信息"

        # 添加表头
        headers = [
            "网络地址",
            "子网掩码",
            "前缀长度",
            "广播地址",
            "可用主机范围",
            "可用主机数量",
            "CIDR表示",
        ]
        ws.append(headers)

        # 设置表头样式
        for cell in ws[1]:
            cell.font = Font(bold=True)
            cell.alignment = Alignment(horizontal="center")

        # 添加数据
        for item in data:
            host_range = f"{item['host_range_start']} - {item['host_range_end']}"
            ws.append(
                [
                    item["network_address"],
                    item["subnet_mask"],
                    item["prefix_length"],
                    item["broadcast_address"],
                    host_range,
                    item["number_of_hosts"],
                    item["cidr"],
                ]
            )

        # 调整列宽
        column_widths = [15, 15, 12, 15, 25, 15, 18]
        for i, width in enumerate(column_widths, 1):
            ws.column_dimensions[chr(64 + i)].width = width

        # 保存Excel文件
        wb.save(file_path)
        return True
    except Exception as e:
        print(f"Excel导出失败: {str(e)}")
        return False
